// Code generated by protoc-gen-gogo.
// source: dbtesterpb/flag_zookeeper.proto
// DO NOT EDIT!

package dbtesterpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Flag_Zookeeper_R3_4_9 struct {
	// JavaDJuteMaxBuffer is for '-Djute.maxbuffer' flag.
	// It is the maximum size, in bytes, of a request or response.
	// See http://zookeeper.apache.org/doc/trunk/zookeeperAdmin.html#Unsafe+Options for more.
	JavaDJuteMaxBuffer uint64 `protobuf:"varint,1,opt,name=JavaDJuteMaxBuffer,proto3" json:"JavaDJuteMaxBuffer,omitempty" yaml:"java_d_jute_max_buffer"`
	// JavaXms is for '-Xms' flag (minimum Java heap size).
	// See https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/jrdocs/refman/optionX.html for more.
	JavaXms string `protobuf:"bytes,2,opt,name=JavaXms,proto3" json:"JavaXms,omitempty" yaml:"java_xms"`
	// JavaXmx is for '-Xmx' flag (maximum Java heap size).
	// See https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/jrdocs/refman/optionX.html for more.
	JavaXmx string `protobuf:"bytes,3,opt,name=JavaXmx,proto3" json:"JavaXmx,omitempty" yaml:"java_xmx"`
	// MyID contains a single integer in human readable ASCII text that represents the server id.
	// Each ZooKeeper server has a unique id. This id is used in two places: the myid file and the
	// configuration file. The myid file identifies the server that corresponds to the given data directory.
	// See http://zookeeper.apache.org/doc/trunk/zookeeperAdmin.html#sc_dataFileManagement for more.
	MyID uint32 `protobuf:"varint,100,opt,name=MyID,proto3" json:"MyID,omitempty"`
	// ClientPort is by default '2181'.
	// No need to set manually. Inherited from 'database_port_to_connect'.
	ClientPort int64 `protobuf:"varint,101,opt,name=ClientPort,proto3" json:"ClientPort,omitempty"`
	// See http://zookeeper.apache.org/doc/trunk/zookeeperAdmin.html for more.
	TickTime             int64 `protobuf:"varint,102,opt,name=TickTime,proto3" json:"TickTime,omitempty" yaml:"tick_time"`
	InitLimit            int64 `protobuf:"varint,103,opt,name=InitLimit,proto3" json:"InitLimit,omitempty" yaml:"init_limit"`
	SyncLimit            int64 `protobuf:"varint,104,opt,name=SyncLimit,proto3" json:"SyncLimit,omitempty" yaml:"sync_limit"`
	SnapCount            int64 `protobuf:"varint,105,opt,name=SnapCount,proto3" json:"SnapCount,omitempty" yaml:"snap_count"`
	MaxClientConnections int64 `protobuf:"varint,106,opt,name=MaxClientConnections,proto3" json:"MaxClientConnections,omitempty" yaml:"max_client_connections"`
}

func (m *Flag_Zookeeper_R3_4_9) Reset()         { *m = Flag_Zookeeper_R3_4_9{} }
func (m *Flag_Zookeeper_R3_4_9) String() string { return proto.CompactTextString(m) }
func (*Flag_Zookeeper_R3_4_9) ProtoMessage()    {}
func (*Flag_Zookeeper_R3_4_9) Descriptor() ([]byte, []int) {
	return fileDescriptorFlagZookeeper, []int{0}
}

type Flag_Zookeeper_R3_5_2Alpha struct {
	// JavaDJuteMaxBuffer is for '-Djute.maxbuffer' flag.
	// It is the maximum size, in bytes, of a request or response.
	// See http://zookeeper.apache.org/doc/trunk/zookeeperAdmin.html#Unsafe+Options for more.
	JavaDJuteMaxBuffer uint64 `protobuf:"varint,1,opt,name=JavaDJuteMaxBuffer,proto3" json:"JavaDJuteMaxBuffer,omitempty" yaml:"java_d_jute_max_buffer"`
	// JavaXms is for '-Xms' flag (minimum Java heap size).
	// See https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/jrdocs/refman/optionX.html for more.
	JavaXms string `protobuf:"bytes,2,opt,name=JavaXms,proto3" json:"JavaXms,omitempty" yaml:"java_xms"`
	// JavaXmx is for '-Xmx' flag (maximum Java heap size).
	// See https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/jrdocs/refman/optionX.html for more.
	JavaXmx string `protobuf:"bytes,3,opt,name=JavaXmx,proto3" json:"JavaXmx,omitempty" yaml:"java_xmx"`
	// MyID contains a single integer in human readable ASCII text that represents the server id.
	// Each ZooKeeper server has a unique id. This id is used in two places: the myid file and the
	// configuration file. The myid file identifies the server that corresponds to the given data directory.
	// See http://zookeeper.apache.org/doc/trunk/zookeeperAdmin.html#sc_dataFileManagement for more.
	MyID uint32 `protobuf:"varint,100,opt,name=MyID,proto3" json:"MyID,omitempty"`
	// ClientPort is by default '2181'.
	// No need to set manually. Inherited from 'database_port_to_connect'.
	ClientPort int64 `protobuf:"varint,101,opt,name=ClientPort,proto3" json:"ClientPort,omitempty"`
	// See http://zookeeper.apache.org/doc/trunk/zookeeperAdmin.html for more.
	TickTime             int64 `protobuf:"varint,102,opt,name=TickTime,proto3" json:"TickTime,omitempty" yaml:"tick_time"`
	InitLimit            int64 `protobuf:"varint,103,opt,name=InitLimit,proto3" json:"InitLimit,omitempty" yaml:"init_limit"`
	SyncLimit            int64 `protobuf:"varint,104,opt,name=SyncLimit,proto3" json:"SyncLimit,omitempty" yaml:"sync_limit"`
	SnapCount            int64 `protobuf:"varint,105,opt,name=SnapCount,proto3" json:"SnapCount,omitempty" yaml:"snap_count"`
	MaxClientConnections int64 `protobuf:"varint,106,opt,name=MaxClientConnections,proto3" json:"MaxClientConnections,omitempty" yaml:"max_client_connections"`
}

func (m *Flag_Zookeeper_R3_5_2Alpha) Reset()         { *m = Flag_Zookeeper_R3_5_2Alpha{} }
func (m *Flag_Zookeeper_R3_5_2Alpha) String() string { return proto.CompactTextString(m) }
func (*Flag_Zookeeper_R3_5_2Alpha) ProtoMessage()    {}
func (*Flag_Zookeeper_R3_5_2Alpha) Descriptor() ([]byte, []int) {
	return fileDescriptorFlagZookeeper, []int{1}
}

func init() {
	proto.RegisterType((*Flag_Zookeeper_R3_4_9)(nil), "dbtesterpb.flag__zookeeper__r3_4_9")
	proto.RegisterType((*Flag_Zookeeper_R3_5_2Alpha)(nil), "dbtesterpb.flag__zookeeper__r3_5_2_alpha")
}
func (m *Flag_Zookeeper_R3_4_9) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flag_Zookeeper_R3_4_9) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.JavaDJuteMaxBuffer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.JavaDJuteMaxBuffer))
	}
	if len(m.JavaXms) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(len(m.JavaXms)))
		i += copy(dAtA[i:], m.JavaXms)
	}
	if len(m.JavaXmx) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(len(m.JavaXmx)))
		i += copy(dAtA[i:], m.JavaXmx)
	}
	if m.MyID != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.MyID))
	}
	if m.ClientPort != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.ClientPort))
	}
	if m.TickTime != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.TickTime))
	}
	if m.InitLimit != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.InitLimit))
	}
	if m.SyncLimit != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.SyncLimit))
	}
	if m.SnapCount != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.SnapCount))
	}
	if m.MaxClientConnections != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.MaxClientConnections))
	}
	return i, nil
}

func (m *Flag_Zookeeper_R3_5_2Alpha) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flag_Zookeeper_R3_5_2Alpha) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.JavaDJuteMaxBuffer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.JavaDJuteMaxBuffer))
	}
	if len(m.JavaXms) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(len(m.JavaXms)))
		i += copy(dAtA[i:], m.JavaXms)
	}
	if len(m.JavaXmx) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(len(m.JavaXmx)))
		i += copy(dAtA[i:], m.JavaXmx)
	}
	if m.MyID != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.MyID))
	}
	if m.ClientPort != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.ClientPort))
	}
	if m.TickTime != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.TickTime))
	}
	if m.InitLimit != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.InitLimit))
	}
	if m.SyncLimit != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.SyncLimit))
	}
	if m.SnapCount != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.SnapCount))
	}
	if m.MaxClientConnections != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintFlagZookeeper(dAtA, i, uint64(m.MaxClientConnections))
	}
	return i, nil
}

func encodeFixed64FlagZookeeper(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32FlagZookeeper(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFlagZookeeper(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Flag_Zookeeper_R3_4_9) Size() (n int) {
	var l int
	_ = l
	if m.JavaDJuteMaxBuffer != 0 {
		n += 1 + sovFlagZookeeper(uint64(m.JavaDJuteMaxBuffer))
	}
	l = len(m.JavaXms)
	if l > 0 {
		n += 1 + l + sovFlagZookeeper(uint64(l))
	}
	l = len(m.JavaXmx)
	if l > 0 {
		n += 1 + l + sovFlagZookeeper(uint64(l))
	}
	if m.MyID != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.MyID))
	}
	if m.ClientPort != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.ClientPort))
	}
	if m.TickTime != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.TickTime))
	}
	if m.InitLimit != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.InitLimit))
	}
	if m.SyncLimit != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.SyncLimit))
	}
	if m.SnapCount != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.SnapCount))
	}
	if m.MaxClientConnections != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.MaxClientConnections))
	}
	return n
}

func (m *Flag_Zookeeper_R3_5_2Alpha) Size() (n int) {
	var l int
	_ = l
	if m.JavaDJuteMaxBuffer != 0 {
		n += 1 + sovFlagZookeeper(uint64(m.JavaDJuteMaxBuffer))
	}
	l = len(m.JavaXms)
	if l > 0 {
		n += 1 + l + sovFlagZookeeper(uint64(l))
	}
	l = len(m.JavaXmx)
	if l > 0 {
		n += 1 + l + sovFlagZookeeper(uint64(l))
	}
	if m.MyID != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.MyID))
	}
	if m.ClientPort != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.ClientPort))
	}
	if m.TickTime != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.TickTime))
	}
	if m.InitLimit != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.InitLimit))
	}
	if m.SyncLimit != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.SyncLimit))
	}
	if m.SnapCount != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.SnapCount))
	}
	if m.MaxClientConnections != 0 {
		n += 2 + sovFlagZookeeper(uint64(m.MaxClientConnections))
	}
	return n
}

func sovFlagZookeeper(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFlagZookeeper(x uint64) (n int) {
	return sovFlagZookeeper(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Flag_Zookeeper_R3_4_9) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlagZookeeper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: flag__zookeeper__r3_4_9: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: flag__zookeeper__r3_4_9: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaDJuteMaxBuffer", wireType)
			}
			m.JavaDJuteMaxBuffer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavaDJuteMaxBuffer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaXms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlagZookeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JavaXms = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaXmx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlagZookeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JavaXmx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyID", wireType)
			}
			m.MyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MyID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPort", wireType)
			}
			m.ClientPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickTime", wireType)
			}
			m.TickTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitLimit", wireType)
			}
			m.InitLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncLimit", wireType)
			}
			m.SyncLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapCount", wireType)
			}
			m.SnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClientConnections", wireType)
			}
			m.MaxClientConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxClientConnections |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlagZookeeper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlagZookeeper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flag_Zookeeper_R3_5_2Alpha) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlagZookeeper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: flag__zookeeper__r3_5_2_alpha: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: flag__zookeeper__r3_5_2_alpha: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaDJuteMaxBuffer", wireType)
			}
			m.JavaDJuteMaxBuffer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JavaDJuteMaxBuffer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaXms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlagZookeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JavaXms = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaXmx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlagZookeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JavaXmx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyID", wireType)
			}
			m.MyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MyID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPort", wireType)
			}
			m.ClientPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickTime", wireType)
			}
			m.TickTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitLimit", wireType)
			}
			m.InitLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncLimit", wireType)
			}
			m.SyncLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapCount", wireType)
			}
			m.SnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClientConnections", wireType)
			}
			m.MaxClientConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxClientConnections |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlagZookeeper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlagZookeeper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlagZookeeper(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlagZookeeper
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlagZookeeper
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFlagZookeeper
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFlagZookeeper
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFlagZookeeper(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFlagZookeeper = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlagZookeeper   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("dbtesterpb/flag_zookeeper.proto", fileDescriptorFlagZookeeper) }

var fileDescriptorFlagZookeeper = []byte{
	// 442 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x94, 0xcf, 0x6e, 0xd3, 0x30,
	0x18, 0xc0, 0x17, 0x56, 0x01, 0xb3, 0x84, 0x00, 0x53, 0x84, 0x85, 0xb4, 0xa4, 0xf8, 0xd4, 0xcb,
	0x56, 0x44, 0xe1, 0x00, 0xc7, 0x74, 0x97, 0x4d, 0x54, 0x82, 0x30, 0x24, 0x6e, 0x96, 0xe3, 0x3a,
	0xa9, 0xdb, 0xd8, 0x8e, 0x12, 0x67, 0x4a, 0x79, 0x12, 0x9e, 0x80, 0x13, 0x0f, 0xb2, 0x23, 0x4f,
	0x50, 0x41, 0x79, 0x83, 0x3c, 0x01, 0x8a, 0xa3, 0x25, 0x15, 0x74, 0x6f, 0xd0, 0xdb, 0xf7, 0xe7,
	0xf7, 0xfb, 0xa2, 0xe8, 0xfb, 0x64, 0xe0, 0xcd, 0x42, 0xc3, 0x73, 0xc3, 0xb3, 0x34, 0x1c, 0x45,
	0x09, 0x8d, 0xc9, 0x57, 0xad, 0x97, 0x9c, 0xa7, 0x3c, 0x3b, 0x4d, 0x33, 0x6d, 0x34, 0x04, 0x1d,
	0xf0, 0xfc, 0x24, 0x16, 0x66, 0x5e, 0x84, 0xa7, 0x4c, 0xcb, 0x51, 0xac, 0x63, 0x3d, 0xb2, 0x48,
	0x58, 0x44, 0x36, 0xb3, 0x89, 0x8d, 0x1a, 0x15, 0x7f, 0xef, 0x81, 0x67, 0x76, 0x66, 0x37, 0x94,
	0x90, 0x6c, 0x4c, 0x5e, 0x93, 0xb7, 0xf0, 0x23, 0x80, 0x17, 0xf4, 0x8a, 0x9e, 0x5d, 0x14, 0x86,
	0x4f, 0x69, 0xe9, 0x17, 0x51, 0xc4, 0x33, 0xe4, 0x0c, 0x9c, 0x61, 0xcf, 0x7f, 0x51, 0xad, 0xbd,
	0xe3, 0x15, 0x95, 0xc9, 0x3b, 0xbc, 0xa0, 0x57, 0x94, 0xcc, 0xc8, 0xa2, 0x30, 0x9c, 0x48, 0x5a,
	0x92, 0xd0, 0x72, 0x38, 0xd8, 0x21, 0xc3, 0x13, 0x70, 0xaf, 0xae, 0x7e, 0x91, 0x39, 0xba, 0x33,
	0x70, 0x86, 0x47, 0xfe, 0x93, 0x6a, 0xed, 0x3d, 0xdc, 0x9a, 0x53, 0xca, 0x1c, 0x07, 0x37, 0x4c,
	0x87, 0x97, 0xe8, 0xf0, 0x16, 0xbc, 0x6c, 0xf1, 0x12, 0x42, 0xd0, 0x9b, 0xae, 0xce, 0xcf, 0xd0,
	0x6c, 0xe0, 0x0c, 0x1f, 0x04, 0x36, 0x86, 0x2e, 0x00, 0x93, 0x44, 0x70, 0x65, 0x3e, 0xe8, 0xcc,
	0x20, 0x3e, 0x70, 0x86, 0x87, 0xc1, 0x56, 0x05, 0xbe, 0x04, 0xf7, 0x2f, 0x05, 0x5b, 0x5e, 0x0a,
	0xc9, 0x51, 0x54, 0x77, 0xfd, 0x7e, 0xb5, 0xf6, 0x1e, 0x35, 0xdf, 0x30, 0x82, 0x2d, 0x89, 0x11,
	0x92, 0xe3, 0xa0, 0xa5, 0xe0, 0x18, 0x1c, 0x9d, 0x2b, 0x61, 0xde, 0x0b, 0x29, 0x0c, 0x8a, 0xad,
	0xf2, 0xb4, 0x5a, 0x7b, 0x8f, 0x1b, 0x45, 0x28, 0x61, 0x48, 0x52, 0xf7, 0x70, 0xd0, 0x71, 0xb5,
	0xf4, 0x69, 0xa5, 0x58, 0x23, 0xcd, 0xff, 0x95, 0xf2, 0x95, 0x62, 0xad, 0xd4, 0x72, 0x56, 0x52,
	0x34, 0x9d, 0xe8, 0x42, 0x19, 0x24, 0xfe, 0x93, 0x14, 0x4d, 0x09, 0xab, 0x7b, 0xb5, 0x74, 0xc3,
	0xc1, 0xcf, 0xa0, 0x3f, 0xa5, 0x65, 0xf3, 0x87, 0x13, 0xad, 0x14, 0x67, 0x46, 0x68, 0x95, 0xa3,
	0x85, 0xf5, 0xb7, 0xf6, 0x56, 0xef, 0x8a, 0x59, 0x8c, 0xb0, 0x8e, 0xc3, 0xc1, 0x4e, 0x1d, 0xff,
	0xe8, 0x81, 0xe3, 0x5d, 0x87, 0xf2, 0x86, 0xbc, 0x22, 0x34, 0x49, 0xe7, 0x74, 0x7f, 0x2e, 0xfb,
	0x73, 0x69, 0xcb, 0x7e, 0xff, 0xfa, 0xb7, 0x7b, 0x70, 0xbd, 0x71, 0x9d, 0x9f, 0x1b, 0xd7, 0xf9,
	0xb5, 0x71, 0x9d, 0x6f, 0x7f, 0xdc, 0x83, 0xf0, 0xae, 0x7d, 0x74, 0xc6, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x29, 0x97, 0xdc, 0xa7, 0xd2, 0x04, 0x00, 0x00,
}
